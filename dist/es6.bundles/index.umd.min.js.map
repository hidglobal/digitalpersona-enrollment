{"version":3,"file":"index.umd.min.js","sources":["../es6/private/enroller.js","../es6/tokens/otp/actions.js","../es6/tokens/password/actions.js","../es6/tokens/u2f/enroll.js","../es6/tokens/cards/enroll.js","../es6/enrollmentContext.js","../es6/tokens/face/enroll.js","../es6/tokens/fingerprints/enroll.js","../es6/tokens/password/enroll.js","../es6/tokens/pin/enroll.js","../es6/tokens/questions/enroll.js","../es6/tokens/otp/enroll.js"],"sourcesContent":["import { User, Ticket } from '@digitalpersona/core';\r\n/** @internal */\r\nexport class Enroller {\r\n    constructor(context) {\r\n        this.context = context;\r\n        if (!this.context)\r\n            throw new Error(\"context\");\r\n    }\r\n    _canEnroll(credId) {\r\n        return this.context.enrollService.IsEnrollmentAllowed(new Ticket(this.context.securityOfficer || \"\"), this.context.getUser(), credId);\r\n    }\r\n    _enroll(credential) {\r\n        if (this.context.user instanceof User) {\r\n            return this.context.enrollService.EnrollAltusUserCredentials(new Ticket(this.context.securityOfficer || \"\"), this.context.user, credential);\r\n        }\r\n        else {\r\n            return this.context.enrollService.EnrollUserCredentials(new Ticket(this.context.securityOfficer || \"\"), new Ticket(this.context.user), credential);\r\n        }\r\n    }\r\n    _unenroll(credential) {\r\n        if (this.context.user instanceof User) {\r\n            return this.context.enrollService.DeleteAltusUserCredentials(new Ticket(this.context.securityOfficer || \"\"), this.context.user, credential);\r\n        }\r\n        else {\r\n            return this.context.enrollService.DeleteUserCredentials(new Ticket(this.context.securityOfficer || \"\"), new Ticket(this.context.user), credential);\r\n        }\r\n    }\r\n}\r\n//# sourceMappingURL=enroller.js.map","/** @internal */\r\nexport var CustomAction;\r\n(function (CustomAction) {\r\n    CustomAction[CustomAction[\"SendEmailVerificationRequest\"] = 16] = \"SendEmailVerificationRequest\";\r\n    CustomAction[CustomAction[\"SendSMSRequest\"] = 513] = \"SendSMSRequest\";\r\n    CustomAction[CustomAction[\"SendEmailRequest\"] = 514] = \"SendEmailRequest\";\r\n    CustomAction[CustomAction[\"UnlockActiveIdHardwareToken\"] = 515] = \"UnlockActiveIdHardwareToken\";\r\n})(CustomAction || (CustomAction = {}));\r\n//# sourceMappingURL=actions.js.map","/** @internal */\r\nexport var CustomAction;\r\n(function (CustomAction) {\r\n    CustomAction[CustomAction[\"PasswordRandomization\"] = 4] = \"PasswordRandomization\";\r\n    CustomAction[CustomAction[\"PasswordReset\"] = 13] = \"PasswordReset\";\r\n})(CustomAction || (CustomAction = {}));\r\n//# sourceMappingURL=actions.js.map","import * as u2fApi from 'u2f-api';\r\nimport { Credential, Base64Url } from '@digitalpersona/core';\r\nimport { Enroller } from '../../private';\r\n/**\r\n * Universal Second Factor (U2F) enrollment API.\r\n */\r\nexport class U2FEnroll extends Enroller {\r\n    /** Constructs a new U2F enrollment API object.\r\n     * @param context - an {@link EnrollmentContext|enrollment context}.\r\n     * @param appId - an AppID of the service.\r\n     */\r\n    constructor(context, appId) {\r\n        super(context);\r\n        if (!appId)\r\n            throw new Error(\"appId\");\r\n        this.appId = appId;\r\n    }\r\n    /** Reads a U2F enrollment availability.\r\n     * @returns a fulfilled promise when a U2F can be enrolled, a rejected promise otherwise.\r\n     */\r\n    canEnroll() {\r\n        return super._canEnroll(Credential.U2F);\r\n    }\r\n    /**\r\n     * Enrolls a U2F token.\r\n     * @returns a promise to perform the enrollment or reject in case of an error.\r\n     */\r\n    enroll() {\r\n        const version = \"U2F_V2\";\r\n        const appId = this.appId;\r\n        const timestamp = Math.round(new Date().getTime() / (U2FEnroll.TIME_WINDOW * 1000));\r\n        const challenge = Base64Url.fromUtf16(timestamp.toString());\r\n        const registerRequests = [{ version, appId, challenge }];\r\n        return u2fApi\r\n            .register(registerRequests, [], U2FEnroll.TIMEOUT)\r\n            .then((response) => super._enroll(new Credential(Credential.U2F, Object.assign({ version, appId }, response))));\r\n    }\r\n    /** Deletes the U2F enrollment.\r\n     * @returns a promise to delete the enrollment or reject in case of an error.\r\n     */\r\n    unenroll() {\r\n        return super._unenroll(new Credential(Credential.U2F));\r\n    }\r\n}\r\nU2FEnroll.TIMEOUT = 20;\r\nU2FEnroll.TIME_WINDOW = 30;\r\n//# sourceMappingURL=enroll.js.map","import { Credential, Utf8 } from '@digitalpersona/core';\r\nimport { Enroller } from '../../private';\r\n/**\r\n * Smartcard enrollment API.\r\n */\r\nexport class SmartCardEnroll extends Enroller {\r\n    /** Constructs a new smartcard enrollment API object.\r\n     * @param context - an {@link EnrollmentContext|enrollment context}.\r\n     */\r\n    constructor(context) {\r\n        super(context);\r\n    }\r\n    /** Reads a list of enrolled cards.\r\n     * @returns a promise to return a list of user's enrolled cards.\r\n     */\r\n    getEnrolledCards() {\r\n        return this.context.enrollService\r\n            .GetEnrollmentData(this.context.getUser(), Credential.SmartCard)\r\n            .then(data => JSON.parse(Utf8.fromBase64Url(data)));\r\n    }\r\n    /** Reads a card enrollment availability.\r\n     * @returns a fulfilled promise when a card can be enrolled, a rejected promise otherwise.\r\n     */\r\n    canEnroll() {\r\n        return super._canEnroll(Credential.SmartCard);\r\n    }\r\n    /** Enrolls a card.\r\n     * @param cardData - a card enrollment data obtained using {@link CardsReader.getCardEnrollData}.\r\n     * @returns a promise to perform the enrollment or reject in case of an error.\r\n     */\r\n    enroll(cardData) {\r\n        return super._enroll(new Credential(Credential.SmartCard, cardData));\r\n    }\r\n    /**\r\n     * Deletes a specific smart card enrollment defined by its pubilc key hash.\r\n     * @param keyHash - a key hash of the card. If not provided, all smartcard enrollments will be deleted.\r\n     * @returns a promise to delete the enrollment or reject in case of an error.\r\n     */\r\n    unenroll(keyHash) {\r\n        return super._unenroll(new Credential(Credential.SmartCard, keyHash));\r\n    }\r\n}\r\n/**\r\n * Contactless card enrollment API.\r\n */\r\nexport class ContactlessCardEnroll extends Enroller {\r\n    /** Constructs a new contactless card enrollment API object.\r\n     * @param context - an {@link EnrollmentContext|enrollment context}.\r\n     */\r\n    constructor(context) {\r\n        super(context);\r\n    }\r\n    /** Reads a card enrollment availability.\r\n     * @returns a fulfilled promise when a card can be enrolled, a rejected promise otherwise.\r\n     */\r\n    canEnroll() {\r\n        return super._canEnroll(Credential.ContactlessCard);\r\n    }\r\n    /** Enrolls a card.\r\n     * @param cardData - a card enrollment data obtained using {@link CardsReader.getCardEnrollData}.\r\n     * @returns a promise to perform the enrollment or reject in case of an error.\r\n     */\r\n    enroll(cardData) {\r\n        return super._enroll(new Credential(Credential.ContactlessCard, cardData));\r\n    }\r\n    /** Deletes the card enrollment.\r\n     * @returns a promise to delete the enrollment or reject in case of an error.\r\n     */\r\n    unenroll() {\r\n        return super._unenroll(new Credential(Credential.ContactlessCard));\r\n    }\r\n}\r\n/**\r\n * Proximity card enrollment API.\r\n */\r\nexport class ProximityCardEnroll extends Enroller {\r\n    /** Constructs a new proximity card enrollment API object.\r\n     * @param context - an {@link EnrollmentContext|enrollment context}.\r\n     */\r\n    constructor(context) {\r\n        super(context);\r\n    }\r\n    /** Reads a card enrollment availability.\r\n     * @returns a fulfilled promise when a card can be enrolled, a rejected promise otherwise.\r\n     */\r\n    canEnroll() {\r\n        return super._canEnroll(Credential.ProximityCard);\r\n    }\r\n    /** Enrolls a card.\r\n     * @param cardData - a card enrollment data obtained using {@link CardsReader.getCardEnrollData}.\r\n     * @returns a promise to perform the enrollment or reject in case of an error.\r\n     */\r\n    enroll(cardData) {\r\n        return super._enroll(new Credential(Credential.ProximityCard, cardData));\r\n    }\r\n    /** Deletes the card enrollment.\r\n     * @returns a promise to delete the enrollment or reject in case of an error.\r\n     */\r\n    unenroll() {\r\n        return super._unenroll(new Credential(Credential.ProximityCard));\r\n    }\r\n}\r\n//# sourceMappingURL=enroll.js.map","import { User } from '@digitalpersona/core';\r\n/**\r\n * Enrollment context.\r\n * @remarks\r\n * Pass the context object into token enrollment APIs. The single context may be shared.\r\n */\r\nexport class EnrollmentContext {\r\n    constructor(\r\n    /** DigitalPersona Enrollment web service client */\r\n    enrollService, \r\n    /** A JSON Web Token or a username of a user whose credentials are to be enrolled.\r\n     * @remarks\r\n     * Only DigitalPersona users (formerly \"Altus User\") can be enrolled without authentication,\r\n     * i.e. using only a user name. Other users must be authenticated, i.e. have a JSON Web Token.\r\n     */\r\n    user, \r\n    /** An optional JSON Web Token of a security officer performing an attended enrollment.\r\n     * If not provided, the API should try to use a user's own token instead for a self-enrollment.\r\n     * In this case the user must be allowed to do self-enrollment.\r\n     */\r\n    securityOfficer) {\r\n        this.enrollService = enrollService;\r\n        this.user = user;\r\n        this.securityOfficer = securityOfficer;\r\n        if (!this.enrollService)\r\n            throw new Error(\"enrollService\");\r\n        if (!this.user)\r\n            throw new Error(\"user\");\r\n        if (!this.securityOfficer && !(this.user instanceof User))\r\n            this.securityOfficer = this.user;\r\n    }\r\n    /**\r\n     * Check is the user has an authentication token, or just a user name.\r\n     * @returns `true` if user identity represented by an authenticatication token, `false` otherwise.\r\n     */\r\n    isAuthenticated() {\r\n        return !(this.user instanceof User);\r\n    }\r\n    /**\r\n     * Returns user identity in a form of authentication token.\r\n     * @remarks\r\n     * The user must be authenticated.\r\n     */\r\n    getJWT() {\r\n        return (this.user instanceof User) ? \"\" : this.user;\r\n    }\r\n    /**\r\n     * Returns user identity in a form of a username.\r\n     * @remarks\r\n     * The user may be authenticated or not. If authenticated, the username will be produced from\r\n     * the authentication token claims.\r\n     */\r\n    getUser() {\r\n        return (this.user instanceof User) ? this.user : User.fromJWT(this.user);\r\n    }\r\n}\r\n//# sourceMappingURL=enrollmentContext.js.map","import { Credential } from '@digitalpersona/core';\r\nimport { Enroller } from '../../private';\r\n/**\r\n * Face enrollment API.\r\n */\r\nexport class FaceEnroll extends Enroller {\r\n    /** Constructs a new face enrollment API object.\r\n     * @param context - an {@link EnrollmentContext|enrollment context}.\r\n     */\r\n    constructor(context) {\r\n        super(context);\r\n    }\r\n    /** Reads a face enrollment availability.\r\n     * @returns a fulfilled promise when a face can be enrolled, a rejected promise otherwise.\r\n     */\r\n    canEnroll() {\r\n        return super._canEnroll(Credential.Face);\r\n    }\r\n    /** Enrolls a face.\r\n     * @param samples - a collection of face images.\r\n     * @returns a promise to perform the enrollment or reject in case of an error.\r\n     */\r\n    enroll(samples) {\r\n        return super._enroll(new Credential(Credential.Face, samples));\r\n    }\r\n    /** Deletes the face enrollment.\r\n     * @returns a promise to delete the enrollment or reject in case of an error.\r\n     */\r\n    unenroll() {\r\n        return super._unenroll(new Credential(Credential.Face));\r\n    }\r\n}\r\n//# sourceMappingURL=enroll.js.map","import { Credential, Utf8, Finger } from '@digitalpersona/core';\r\nimport { Enroller } from '../../private';\r\n/**\r\n * Fingerprint enrollment API.\r\n */\r\nexport class FingerprintsEnroll extends Enroller {\r\n    /** Constructs a new fingerprint enrollment API object.\r\n     * @param context - an {@link EnrollmentContext|enrollment context}.\r\n     */\r\n    constructor(context) {\r\n        super(context);\r\n    }\r\n    /** Reads a fingerprint enrollment status.\r\n     * @returns a promise to return fingerprint enrollment data. The data is a collection of enrolled fingers.\r\n     */\r\n    getEnrolledFingers() {\r\n        return this.context.enrollService\r\n            .GetEnrollmentData(this.context.getUser(), Credential.Fingerprints)\r\n            .then(data => JSON.parse(Utf8.fromBase64Url(data))\r\n            .map(item => Finger.fromJson(item)));\r\n    }\r\n    /** Reads a fingerprint enrollment availability.\r\n     * @returns a fulfilled promise when fingerprints can be enrolled, a rejected promise otherwise.\r\n     */\r\n    canEnroll() {\r\n        return super._canEnroll(Credential.Fingerprints);\r\n    }\r\n    /** Enrolls a fingerprint.\r\n     * @param position - a position of a finger to enroll\r\n     * @param samples - a collection of fingerprint scans.\r\n     * @returns a promise to perform the enrollment or reject in case of an error.\r\n     */\r\n    enroll(position, samples) {\r\n        const data = {\r\n            position: (position instanceof Finger) ? position.position : position,\r\n            samples,\r\n        };\r\n        return super._enroll(new Credential(Credential.Fingerprints, data));\r\n    }\r\n    /** Deletes the fingerprint enrollment.\r\n     * @param position - a position(s) of a finger(s) to delete.\r\n     *                   If not defined, all enrolled fingerprintss will be deleted.\r\n     * @returns a promise to delete the enrollment or reject in case of an error.\r\n     */\r\n    unenroll(position) {\r\n        const data = typeof (position) === \"number\" ? [{ position }] :\r\n            (position instanceof Finger) ? [position] :\r\n                (position instanceof Array) ? position.map(p => (p instanceof Finger) ? p.position : p)\r\n                    : null;\r\n        return super._unenroll(new Credential(Credential.Fingerprints, data));\r\n    }\r\n}\r\n//# sourceMappingURL=enroll.js.map","import { Credential, Ticket } from '@digitalpersona/core';\r\nimport { CustomAction } from './actions';\r\nimport { Enroller } from '../../private';\r\n/**\r\n * Password enrollment API.\r\n * @remarks\r\n * As a primary credential, user's password cannot be unenroled, it can only be changed, reset or randomized.\r\n */\r\nexport class PasswordEnroll extends Enroller {\r\n    /** Constructs a new password enrollment API object.\r\n     * @param context - an {@link EnrollmentContext|enrollment context}.\r\n     */\r\n    constructor(context) {\r\n        super(context);\r\n    }\r\n    /** Reads a password change availability.\r\n     * @returns a fulfilled promise when a password can be changed, a rejected promise otherwise.\r\n     */\r\n    canEnroll() {\r\n        return super._canEnroll(Credential.Password);\r\n    }\r\n    /**\r\n     * Changes a password.\r\n     * @param newPassword - a new password.\r\n     * @param oldPassword - a password to replace. Must match the existing password.\r\n     * @returns a promise to perform the password change or reject in case of an error.\r\n     */\r\n    enroll(newPassword, oldPassword) {\r\n        return super._enroll(new Credential(Credential.Password, { oldPassword, newPassword }));\r\n    }\r\n    /**\r\n     * Resets a password.\r\n     * @param newPassword - a new password which will replace any existing password.\r\n     * @returns a promise to perform the password reset or reject in case of an error.\r\n     * @remarks\r\n     * DigitalPersona AD Server supports password randomization only for ActiveDirectory users.\r\n     * DigitalPersona LDS Server supports password randomization only for DigitalPersona users (formerly \"Altus Users\").\r\n     */\r\n    reset(newPassword) {\r\n        return super._enroll(new Credential(Credential.Password, newPassword));\r\n    }\r\n    /**\r\n     * Creates a new strong password with good complexity properties.\r\n     * @returns a promise to return a randomized password.\r\n     * @remarks\r\n     * DigitalPersona AD Server supports password randomization only for ActiveDirectory users.\r\n     * DigitalPersona LDS Server supports password randomization only for DigitalPersona users (formerly \"Altus Users\").\r\n     */\r\n    randomize() {\r\n        return this.context.enrollService.CustomAction(new Ticket(this.context.securityOfficer || \"\"), this.context.getUser(), new Credential(Credential.Password), CustomAction.PasswordRandomization);\r\n    }\r\n}\r\n//# sourceMappingURL=enroll.js.map","import { Credential } from '@digitalpersona/core';\r\nimport { Enroller } from '../../private';\r\n/**\r\n * Personal Identification Number (PIN) enrollment API.\r\n */\r\nexport class PinEnroll extends Enroller {\r\n    /** Constructs a new PIN enrollment API object.\r\n     * @param context - an {@link EnrollmentContext|enrollment context}.\r\n     */\r\n    constructor(context) {\r\n        super(context);\r\n    }\r\n    /** Reads a PIN enrollment availability.\r\n     * @returns a fulfilled promise when a PIN can be enrolled, a rejected promise otherwise.\r\n     */\r\n    canEnroll() {\r\n        return super._canEnroll(Credential.PIN);\r\n    }\r\n    /** Enrolls a PIN.\r\n     * @param pin - a Personal Identification Number (PIN).\r\n     * @returns a promise to perform the enrollment or reject in case of an error.\r\n     */\r\n    enroll(pin) {\r\n        return super._enroll(new Credential(Credential.PIN, pin));\r\n    }\r\n    /** Deletes the PIN enrollment.\r\n     * @returns a promise to delete the enrollment or reject in case of an error.\r\n     */\r\n    unenroll() {\r\n        return super._unenroll(new Credential(Credential.PIN));\r\n    }\r\n}\r\n//# sourceMappingURL=enroll.js.map","import { Credential, Question, Utf8 } from '@digitalpersona/core';\r\nimport { Enroller } from '../../private';\r\n/**\r\n * Security Questions enrollment API.\r\n */\r\nexport class SecurityQuestionsEnroll extends Enroller {\r\n    /** Constructs a new Security Questions enrollment API object.\r\n     * @param context - an {@link EnrollmentContext|enrollment context}.\r\n     */\r\n    constructor(context) {\r\n        super(context);\r\n    }\r\n    /**\r\n     * Reads enrolled Security Questions.\r\n     * @returns a promise to return a collection of enrolled Security Questions.\r\n     */\r\n    getEnrolledQuestions() {\r\n        return this.context.enrollService\r\n            .GetEnrollmentData(this.context.getUser(), Credential.SecurityQuestions)\r\n            .then(data => JSON.parse(Utf8.fromBase64Url(data))\r\n            .map(item => Question.fromJson(item)));\r\n    }\r\n    /** Reads a Security Questions enrollment availability.\r\n     * @returns a fulfilled promise when Security Questions can be enrolled, a rejected promise otherwise.\r\n     */\r\n    canEnroll() {\r\n        return super._canEnroll(Credential.SecurityQuestions);\r\n    }\r\n    /**\r\n     * Enrolls Security Questions.\r\n     * @param questionsWithAnswers - a colelction of user's answers to Security Questions.\r\n     * @returns a promise to perform the enrollment or reject in case of an error.\r\n     */\r\n    enroll(questionsWithAnswers) {\r\n        const equal = (a, b) => a.question.number === b.question.number;\r\n        const unique = (val, idx, arr) => arr.findIndex(qa => equal(qa, val)) === idx;\r\n        const data = questionsWithAnswers\r\n            .filter(qa => qa.question.number === qa.answer.number)\r\n            .filter(unique)\r\n            .sort((a, b) => b.question.number - a.question.number); // server requires reverse order\r\n        return super._enroll(new Credential(Credential.SecurityQuestions, data));\r\n    }\r\n    /** Deletes the Security Question enrollment.\r\n     * @returns a promise to delete the enrollment or reject in case of an error.\r\n     */\r\n    unenroll() {\r\n        return super._unenroll(new Credential(Credential.SecurityQuestions));\r\n    }\r\n}\r\n//# sourceMappingURL=enroll.js.map","import { User, Credential, JWT, Url, Base32, Ticket, Base64Url } from \"@digitalpersona/core\";\r\nimport { Enroller } from \"../../private\";\r\nimport { CustomAction } from \"./actions\";\r\n/**\r\n * One-time password enrollment API.\r\n */\r\nexport class TimeOtpEnroll extends Enroller {\r\n    /** Constructs a new One-Time Password enrollment API object.\r\n     * @param context - an {@link EnrollmentContext|enrollment context}.\r\n     */\r\n    constructor(context) {\r\n        super(context);\r\n    }\r\n    /**\r\n     * Converts a secret key to a Key URI, which will be encode as a QR Code image to scan.\r\n     * @param key - a secret key to convert to a Key URI string.\r\n     * @returns - a promise to return a Key URI string\r\n     * @remarks\r\n     * For Push Notifications fo AD users, make sure the user's token has an `ad_guid` claim.\r\n     * You may need to use `ClaimsService.GetClaims()` method to append this claim to an existing token.\r\n     */\r\n    createKeyUri(key) {\r\n        const type = \"totp\";\r\n        const jwt = this.context.getJWT();\r\n        const claims = JWT.claims(jwt);\r\n        if (!claims)\r\n            return Promise.reject(new Error('NoClaims'));\r\n        const issuer = claims.dom || claims.iss; // will be used as a prefix of a label\r\n        if (!issuer)\r\n            return Promise.reject(new Error('NoIssuer'));\r\n        const uid = claims.uid || claims[\"ad_guid\"]; // required for Push OTP. Also needs TenantID.\r\n        const username = this.context.getUser().name;\r\n        const secret = Base32.fromBytes(key);\r\n        return this.context.enrollService\r\n            .GetEnrollmentData(User.Anonymous(), Credential.OneTimePassword)\r\n            .then(data => {\r\n            const otpData = JSON.parse(data);\r\n            if (!otpData)\r\n                return Promise.reject(new Error(\"NoEnrollmentData\"));\r\n            const pushSupported = uid && otpData.pn_tenant_id;\r\n            const uri = new Url(`otpauth://${type}`, `${issuer}:${username}`, {\r\n                secret,\r\n                issuer,\r\n                apikey: otpData.pn_api_key,\r\n                tenantid: pushSupported ? otpData.pn_tenant_id : undefined,\r\n                useruuid: pushSupported ? uid : undefined,\r\n            });\r\n            return uri.href;\r\n        });\r\n    }\r\n    /**\r\n     * Sends an verification code using SMS to the user's device.\r\n     * @param key - a secret key to \"seed\" an OTP generator and start generating verification codes.\r\n     * @param phoneNumber - a phone number to send a current verification code to.\r\n     */\r\n    sendVerificationCode(key, phoneNumber) {\r\n        return this.context.enrollService\r\n            .CustomAction(Ticket.None(), this.context.getUser(), new Credential(Credential.OneTimePassword, {\r\n            key: Base64Url.fromBytes(key),\r\n            phoneNumber,\r\n        }), CustomAction.SendSMSRequest)\r\n            .then();\r\n    }\r\n    /**\r\n     * Enrolls One-Time Password using a software TOTP (e.g. DigitalPersona app, Google Authenticator etc.)\r\n     * @param code - a verification code entered by a user.\r\n     * @param key - a secret key used to \"seed\" an OTP generator.\r\n     * @param phoneNumber - a phone number the verification code was sent to\r\n     * @returns a promise to perform the enrollment or reject in case of an error.\r\n     */\r\n    enrollSoftwareOtp(code, key, phoneNumber) {\r\n        return super._enroll(new Credential(Credential.OneTimePassword, {\r\n            otp: code,\r\n            key: Base64Url.fromBytes(key),\r\n            phoneNumber,\r\n        }));\r\n    }\r\n    /**\r\n     * Enrolls a hardware TOTP token.\r\n     * @param code - a verification code entered by a user.\r\n     * @param serialNumber - a serial number of the TOTP token.\r\n     * @param counter - an optional counter displayed on some token models.\r\n     * @param timer - an optional timer displayed on some token models\r\n     * @returns a promise to perform the enrollment or reject in case of an error.\r\n     */\r\n    enrollHardwareOtp(code, serialNumber, counter, timer) {\r\n        return super._enroll(new Credential(Credential.OneTimePassword, {\r\n            otp: code,\r\n            serialNumber,\r\n            counter,\r\n            timer,\r\n        }));\r\n    }\r\n    /** Deletes the OTP enrollment.\r\n     * @returns a promise to delete the enrollment or reject in case of an error.\r\n     */\r\n    unenroll() {\r\n        return super._unenroll(new Credential(Credential.OneTimePassword));\r\n    }\r\n}\r\n//# sourceMappingURL=enroll.js.map"],"names":["Enroller","[object Object]","context","this","Error","credId","enrollService","IsEnrollmentAllowed","Ticket","securityOfficer","getUser","credential","user","User","EnrollAltusUserCredentials","EnrollUserCredentials","DeleteAltusUserCredentials","DeleteUserCredentials","CustomAction","U2FEnroll","appId","super","_canEnroll","Credential","U2F","timestamp","Math","round","Date","getTime","TIME_WINDOW","challenge","Base64Url","fromUtf16","toString","registerRequests","version","u2fApi\r\n            .register","TIMEOUT","then","response","_enroll","Object","assign","_unenroll","ContactlessCard","cardData","fromJWT","Face","samples","GetEnrollmentData","Fingerprints","data","JSON","parse","Utf8","fromBase64Url","map","item","Finger","fromJson","position","Array","p","Password","newPassword","oldPassword","PasswordRandomization","PIN","pin","ProximityCard","SecurityQuestions","Question","questionsWithAnswers","filter","qa","question","number","answer","val","idx","arr","findIndex","a","b","equal","sort","SmartCard","keyHash","key","jwt","getJWT","claims","JWT","Promise","reject","issuer","dom","iss","uid","username","name","secret","Base32","fromBytes","Anonymous","OneTimePassword","otpData","pushSupported","pn_tenant_id","Url","apikey","pn_api_key","tenantid","undefined","useruuid","href","phoneNumber","None","SendSMSRequest","code","otp","serialNumber","counter","timer"],"mappings":"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"}